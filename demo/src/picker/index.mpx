<template>
  <!-- ali indicator-style 设置高度会导致错位，这里取消ali高度 -->
  <view class="mpx-time-picker">
    <slot name="header" />
    <picker-view
      class="mpx-time-picker-view"
      immediate-change="{{true}}"
      indicator-style="height: 36px; width: 0;"
      bindchange="changeHandler"
      value="{{pickerIndex}}">
      <picker-view-column>
        <view wx:for="{{ days }}" style="text-align: center; line-height: 36px;" style@ali="" wx:key="value">{{ item.text }}</view>
      </picker-view-column>
      <picker-view-column>
        <view wx:for="{{ hours }}" style="text-align: center; line-height: 36px;" style@ali="" wx:key="value">{{ item.text }}</view>
      </picker-view-column>
      <picker-view-column>
        <view wx:for="{{ minutes }}" style="text-align: center; line-height: 36px;" style@ali=""  wx:key="value">{{ item.text }}</view>
      </picker-view-column>
    </picker-view>
  </view>
</template>

<script>
  import mpx, { createComponent } from '@mpxjs/core'
  import {
    pad,
    formatDate,
    getZeroStamp,
    getDayDiff,
    DAY_TIMESTAMP,
    HOUR_TIMESTAMP,
    MINUTE_TIMESTAMP,
    converterTimeZone,
    changeTimeStampToDate
  } from '../../common/js/date'
  import { warn } from '../../common/js/debug'

  const COMPONENT_NAME = 'mpx-time-picker'

  function generateColumn(min, max, unit, needPad = false, step = 1) {
    const arr = []
    for (let i = min; i <= max; i += step) {
      arr.push({
        value: i,
        text: (needPad ? pad(i) : i) + unit
      })
    }
    return arr
  }
  function _findIndex(columnList, value) {
    if (!columnList && !columnList.length) return 0
    const index = columnList && columnList.findIndex((item) => item.value === value)
    return index >= 0 ? index : 0
  }
  // /**
  //  * 向N取整
  //  * @param num 数字
  //  * @param type 取整类型，0向下，1向上
  //  * @param n 得到n的整数
  //  */
  // function roundToN(num, type=0, n=10) {
  //   return (type ? Math.floor : Math.ceil)(num/n)*n
  // }
  createComponent({
    options: {
      multipleSlots: true
    },
    data: {
      // 由于小程序对在 data 中定义的值会进行序列化，破坏原本的实例类型，所以 now 需要在 created 时再赋值。
      // 时区时间
      customTimeObj:{
        timestamp:0,
        timezone:8,
        date:null
      },
      dayIndex: 0,
      hourIndex: 0,
      minuteIndex: 0,
      selfAnimation: 'hide',
    },
    properties: {
      delay: {
        type: Number,
        value: 15
      },
      day: {
        type: Object,
        value: {
          len: 3,
          filter: ['今日'],
          format: 'M月D日'
        }
      },
      showNow: {
        type: Boolean,
        value: true
      },
      minuteStep: {
        type: Number,
        value: 10
      },
      hourSpan: {
        type: Array,
        // value: [[0, 24]]
        value: [0, 24]
      },
      // 时区，北京为8
      timezone: {
        type: Number,
        value: 8
      },
      useTimezone:{
        type:Boolean,
        value:false
      }
    },

    created() {
      this._updateNow()
    },
    computed: {
      /** 是否展示现在 */
      isShowNow() {
        return this.showNow && this.isNowInclude
      },
      /** 校验当前时间是否在可选范围内 */
      isNowInclude() {
        const nowHour = this.customTimeObj.date && this.customTimeObj.date.getHours()
        if (!nowHour && nowHour !== 0) return false
        return this.normalHours.some((item) => item.value === nowHour)
      },
      normalHours() {
        const text = mpx.i18n.locale === 'en-US' ? '' : '点'
        let [from, to] = this.hourSpan
        to = to >= 24 ? 23 : to - 1
        if (from >= to) return []
        return generateColumn(from, to, text)
        // 以下是支持更复杂的分段情况，业务暂时没有，暂时用不上
        // const hourList = []
        // let lastFrom = 0
        // this.hourSpan.forEach(arr => {
        //   let [from, to] = arr
        //   // 如果起点晚于或等于上一个终点，以上一个终点为起点,
        //   from = from >= lastFrom ? from : lastFrom
        //   to = to >= 24 ? 23 : to - 1
        //   // 如果起点晚于或等于终点，不处理
        //   if (from >= to) return
        //   lastFrom = to + 1
        //   hourList.push(...generateColumn(from, to, text))
        // })
        // return hourList
      },
      // 是否选中今天
      isChooseToday() {
        return this.dayIndex === 0 && this.minday === 0
      },
      // 当前可选最小天数
      minday() {
        return this.partHours.length ? 0 : 1 // 0今天，1 第二天
      },
      NOW() {
        if (mpx.i18n.locale === 'en-US') {
          return {
            value: 'now',
            text: 'Now'
          }
        } else {
          return {
            value: 'now',
            text: '现在'
          }
        }
      },
      /** 最小可选时间 */
      minTime() {
        const minTime = changeTimeStampToDate(this.customTimeObj.timestamp + this.delay * MINUTE_TIMESTAMP)
        // 经产品确认，最早时间颗粒度划分到10,向下取整
        // const minMinute = Math.floor(minTime.getMinutes()/10)*10
        // 2023-8-7 最新的时间颗粒度划分到5，向上取整
        const minMinute = Math.ceil(minTime.getMinutes()/5)*5
        minTime.setMinutes(minMinute, 0, 0)
        return minTime
      },
      days() {
        const days = []
        const dayDiff = getDayDiff(this.minTime, this.customTimeObj.date)

        for (let i = this.minday; i < this.day.len; i++) {
          const timestamp = +this.minTime + i * DAY_TIMESTAMP
          // 如果当天已经没有可选小时了，直接return
          days.push({
            value: timestamp,
            text: (this.day.filter && this.day.filter[dayDiff + i]) || formatDate(changeTimeStampToDate(timestamp), this.day.format, 'i')
          })
        }

        return days
      },
      partHours() {
        let nowHour = this.minTime.getHours()
        const miniHourIndex = this.normalHours.findIndex((item) => item.value >= nowHour)
        const partHours = miniHourIndex >= 0 ? this.normalHours.slice(miniHourIndex) : []
        if (this.isShowNow) {
          partHours.unshift({
            value: this.NOW.value,
            text: this.NOW.text
          })
        }
        return partHours
      },
      hours() {
        return this.isChooseToday ? this.partHours : this.normalHours
      },
      normalMinutes() {
        if (mpx.i18n.locale === 'en-US') {
          return generateColumn(0, 59, '', true, this.minuteStep)
        } else {
          return generateColumn(0, 59, '分', true, this.minuteStep)
        }
      },
      partMinutes() {
        const minValue = this.minTime.getMinutes()
        const startIndex = this.normalMinutes.findIndex((item)=>item.value>=minValue)
        // 截取值最小可选范围
        let parColumn = startIndex>= 0 ? this.normalMinutes.slice(startIndex) : []
        // 如果当前值正好在可选范围，直接返回
        if(parColumn[0] && parColumn[0].value === minValue) return parColumn
        const curItemList = generateColumn(minValue, minValue, mpx.i18n.locale === 'en-US' ? '' : '分', true, this.minuteStep)
        // 当前值大于范围，兜底最大值时间
        if(!parColumn?.length) return curItemList
        // 当前值小于范围，插入minValue值
        else return [...curItemList, ...parColumn]
      },
      minutes() {
        const hourIndex = this.hourIndex
        const isShowNow = this.isShowNow
        if (this.isChooseToday && hourIndex === 0 && isShowNow) {
          return []
        }
        const result = this.isChooseToday && hourIndex === (isShowNow ? 1 : 0) ? this.partMinutes : this.normalMinutes
        return result
      },
      pickerIndex() {
        return [this.dayIndex, this.hourIndex, this.minuteIndex]
      }
    },
    watch: {
      hours(newVal, oldVal) {
          const hour = oldVal[this.hourIndex] && oldVal[this.hourIndex].value
          const index = _findIndex(newVal, hour)
          this.hourIndex = index >= 0 ? index : 0
      },
      minutes(newVal, oldVal) {
          const minute = oldVal[this.minuteIndex] && oldVal[this.minuteIndex].value
          const index = _findIndex(newVal, minute)
          this.minuteIndex = index >= 0 ? index : 0
      }
    },

    methods: {
      // 稳定时区
      getDate(date, changeType) {
        if(this.useTimezone){
          return converterTimeZone(!date ? Date.now() : date, this.timezone, changeType)
        }else{
          return !date ? new Date() : new Date(date)
        }
      },
      /** 校验时间， */
      checkNow() {
        this._updateNow()
        const result = {
          canNow: this.isNowInclude,
          time: this.isNowInclude ? this.NOW : this.getTime(this.days[0], this.hours[0], this.minutes[0])
        }
        return result
      },
      setTime(timestamp) {
        this._updateNow()
        const date = changeTimeStampToDate(timestamp)
        const minTime = this.minTime
        timestamp = date.getTime()

        if (timestamp < +minTime) {
          [this.dayIndex, this.hourIndex, this.minuteIndex] = [0, 0, 0]
        } else {
          // calculate dayIndex
          const dayIndex = getDayDiff(date, minTime) - this.minday

          if (dayIndex >= this.days.length) {
            warn('Use "setTime" to set a time exceeded to the option range do not actually work.', COMPONENT_NAME)
            return
          }

          this.dayIndex = dayIndex
          this.$nextTick(()=>{
            const nowhour = date.getHours()
            const nowhourIndex = _findIndex(this.isChooseToday ? this.partHours : this.normalHours, nowhour)
            this.hourIndex = nowhourIndex >= 0 ? nowhourIndex : 0
            this.$nextTick(()=>{
              const isPartMinuteList = this.isChooseToday && (this.isShowNow ? this.hourIndex === 1 : !this.hourIndex)
              let nowminute = date.getMinutes()
              let nowminuteIndex
              // 选中的partMinutes首个比较特殊，不按照minuteStep走
              if (isPartMinuteList && this.partMinutes[0].value === nowminute) {
                nowminuteIndex = 0
              }else{
                nowminute =  Math.ceil(nowminute / this.minuteStep) * this.minuteStep
                nowminuteIndex = _findIndex(isPartMinuteList ? this.partMinutes : this.normalMinutes, nowminute)
              }
              this.minuteIndex = nowminuteIndex >= 0 ? nowminuteIndex : 0
            })
          })
        }
      },
      _updateNow() {
        let date = this.getDate(Date.now())
        this.customTimeObj = {
          timestamp: +date,
          timezone:this.timezone,
          date:date
        }
      },
      changeHandler(e) {
        // Todo 这样写 安卓真机 skyline报错 Cannot set property '0' of undefined
        // [this.dayIndex, this.hourIndex, this.minuteIndex] = e.detail.value
        this.dayIndex = e.detail.value[0]
        this.hourIndex = e.detail.value[1]
        this.minuteIndex = e.detail.value[2]
        const backResult = `${this.dayIndex}-${this.hourIndex}-${this.minuteIndex}`
        this.$nextTick(() => {
          if (backResult !== `${this.dayIndex}-${this.hourIndex}-${this.minuteIndex}`) {
            // 解决watch变更数据后不更新问题
            this.$forceUpdate()
          }
          const day = this.days[this.dayIndex]
          const hour = this.hours[this.hourIndex]
          const minute = this.minutes[this.minuteIndex]
          this.triggerEvent('change', this.getTime(day, hour, minute))
        })
      },
      getTime(day, hour, minute) {
        let value, text
        if (hour.value === this.NOW.value) {
          value = +this.getDate(Date.now())
          text = this.NOW.text
        } else {
          value = getZeroStamp(changeTimeStampToDate(day.value)) + hour.value * HOUR_TIMESTAMP + minute.value * MINUTE_TIMESTAMP
          text = day.text + ' ' + hour.text + ':' + minute.text
        }
        return {
          value,
          text
        }
      },
      getSelectedInfo () {
        const day = this.days[this.dayIndex]
        const hour = this.hours[this.hourIndex]
        const minute = this.minutes[this.minuteIndex]
        return this.getTime(day, hour, minute)
      }
    }
  })
</script>

<style lang="stylus" scoped>
.mpx-time-picker
  position relative
  text-align center
.mpx-time-picker-view
  font-size 16px
  width 100%
  height 170px
</style>

<script type="application/json">
  {
    "component": true,
    "usingComponents": {}
  }
</script>
