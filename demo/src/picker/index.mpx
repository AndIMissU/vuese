<template>
  <cascade-picker
    wx:ref="picker"
    list="{{dataList}}"
    selectedIndex="{{selectedIndex}}"
    immediateChange="{{immediateChange}}"
    bindpickstart="pickstart"
    bindpickend="pickend"
    bindchange="change"
    bindcolumnChange="columnChange"
    class="{{classes}}">
  </cascade-picker>
</template>

<script>
import { createComponent } from '@mpxjs/core'
import { compareTime, parseTime, padTime, getDayDiff } from './utils'

createComponent({
  properties: {
    delay: {
      type: Number,
      value: 15
    },
    min: {
      type: Number,
      value: Date.now()
    },
    max: {
      type: Number,
      value: 0
    },
    now: {
      type: Number,
      value: Date.now()
    },
    day: {
      type: Object,
      value: {
        len: 3,
        filter: ['今天', '明天', '后天'],
        format: ''
      }
    },
    showNow: {
      type: String,
      value: ''
    },
    minuteStep: {
      type: Number,
      value: 10
    },
    start: {
      type: String,
      value: '09:30'
    },
    end: {
      type: String,
      value: '18:00'
    },
    startSecond: {
      type: String,
      value: ''
    },
    endSecond: {
      type: String,
      value: ''
    },
    selectedIndex: {
      type: Array,
      value: [0, 0, 0]
    },
    selectedTime: {
      type: Number,
      value: 0
    },
    themeType: {
      type: String,
      value: 'dd'
    },
    weekCfg: {
      type: Array,
      value: ['周日', '周一', '周二', '周三', '周四', '周五', '周六']
    },
    immediateChange: {
      type: Boolean
    }
  },
  data: {
    value: {
      selectedIndex: [0, 0, 0],
      selectedText: '',
      selectedTime: 0
    },
    fromSetTime: false
  },
  computed: {
    classes () {
      return `mpx-cascade-picker-${this.themeType}`
    },
    timeInfo () {
      const diff = compareTime(this.start, this.end) > 0
      if (diff) {
        return { start: '00:00', end: this.end, startSecond: this.start, endSecond: '24:00' }
      }
      return { start: this.start, end: this.end, startSecond: this.startSecond, endSecond: this.endSecond }
    },
    dayInfo () {
      const check = []
      const oneDay = 86400000
      const today = new Date(this.now).setHours(0, 0, 0, 0)
      const tommorrow = today + 1 * oneDay
      const afterTommorrow = today + 2 * oneDay
      const len = this.max ? getDayDiff(new Date(this.max), new Date(this.min)) + 1 : this.day.len
      for (let i = 0; i < len; i++) {
        const nDay = this.min + i * oneDay
        const date = new Date(nDay)
        date.setHours(0, 0, 0, 0)
        const month = date.getMonth() + 1
        const day = date.getDate()
        const week = date.getDay()
        const timestamp = date.getTime()
        let text = ''
        if (timestamp === today) text = this.day.filter[0]
        if (timestamp === tommorrow) text = this.day.filter[1]
        if (timestamp === afterTommorrow) text = this.day.filter[2]
        const weekDay = this.weekCfg
        const weekText = weekDay[week]
        check.push({
          text: text || `${month}月${day}日${weekText}`,
          value: timestamp
        })
      }
      const minDate = new Date(this.min)
      // 获取明天的0点时间
      var tomorrowDate = new Date();
      tomorrowDate.setDate(tomorrowDate.getDate() + 1);
      tomorrowDate.setHours(0, 0, 0, 0)
      // 如果展示showNow，并且最小时间为第二天，追加showNow
      if (this.showNow && minDate >= tomorrowDate) {
        check.unshift({
          text: '今天',
          value: today
        })
      }
      return check
    },
    dataList () {
      const start = parseTime(this.timeInfo.start)
      const end = parseTime(this.timeInfo.end)
      // 计算分钟
      const minuteList = []
      const step = this.minuteStep
      for (let m = 0; m < 60; m += step) {
        minuteList.push({ value: padTime(m), text: `${m}分`, disabled: false })
      }
      // 计算小时
      const hourList = []
      for (let h = start.hours; h <= end.hours; h++) {
        hourList.push({ value: padTime(h), text: `${h}点`, disabled: false })
      }
      let secondTime = false
      if (this.timeInfo.startSecond && this.timeInfo.endSecond) {
        const startSecond = parseTime(this.timeInfo.startSecond)
        const endSecond = parseTime(this.timeInfo.endSecond)
        secondTime = true
        for (let h = startSecond.hours; h <= endSecond.hours; h++) {
          hourList.push({ value: padTime(h), text: `${h}点`, disabled: false })
        }
      }
      // 捆绑时间
      hourList.forEach(hour => {
        hour.children = minuteList
      })
      // 筛选时间
      const today = new Date(this.now).setHours(0, 0, 0, 0)
      const list = []
      this.dayInfo.forEach(day => {
        const result = []
        hourList.forEach(hour => {
          const info = Object.assign({}, hour, { children: [] })
          // hour.children.forEach(minute => {
          //   const stepTime = `${hour.value}:${minute.value}`
          //   const timestamp = day.value + (hour.value * 60 * 60 * 1000) + (minute.value * 60 * 1000)
          //   const disabled = (this.max && timestamp > this.max) || (compareTime(this.timeInfo.start, stepTime)) > 0 || (compareTime(this.timeInfo.end, stepTime)) < 0 || (timestamp < this.min)
          //   const disabledSecond = secondTime ? (compareTime(this.timeInfo.startSecond, stepTime)) > 0 || (compareTime(this.timeInfo.endSecond, stepTime)) < 0 || (timestamp < this.min) : true
          //   info.disabled = !(!disabled || !disabledSecond)
          //   const temp = Object.assign({}, minute, { disabled: info.disabled, timestamp })
          //   if (!info.disabled) info.children.push(temp)
          // })
          const hourChildrenLen = hour.children.length
          for (let i = 0; i < hourChildrenLen; i++) {
            const minute = hour.children[i]
            const stepTime = `${hour.value}:${minute.value}`
            const timestamp = day.value + (hour.value * 60 * 60 * 1000) + (minute.value * 60 * 1000)
            const disabled = (this.max && timestamp > this.max) || (compareTime(this.timeInfo.start, stepTime)) > 0 || (compareTime(this.timeInfo.end, stepTime)) < 0 || (timestamp < this.min)
            const disabledSecond = secondTime ? (compareTime(this.timeInfo.startSecond, stepTime)) > 0 || (compareTime(this.timeInfo.endSecond, stepTime)) < 0 || (timestamp < this.min) : true
            if (this.max && !(!disabled || !disabledSecond)) {
              continue
            } else {
              info.disabled = !(!disabled || !disabledSecond)
            }
            const temp = Object.assign({}, minute, { disabled: info.disabled, timestamp })
            if (!info.disabled) info.children.push(temp)
          }
          if (!info.disabled && info.children.length) result.push(info)
        })
        if (day.value === today && this.showNow) {
          const hour = new Date(this.now).getHours()
          const minute = new Date(this.now).getMinutes()
          const stepTime = `${hour}:${minute}`
          const disabled = (compareTime(this.timeInfo.start, stepTime)) > 0 || (compareTime(this.timeInfo.end, stepTime)) < 0
          const disabledSecond = secondTime ? (compareTime(this.timeInfo.startSecond, stepTime)) > 0 || (compareTime(this.timeInfo.endSecond, stepTime)) < 0 : true
          if (!disabled || !disabledSecond) result.unshift({ text: this.showNow, value: '', children: [] })
        }
        if (result.length) list.push(Object.assign({}, day, { children: result }))
      })
      return list
    }
  },
  methods: {
    pickstart() {
      this.triggerEvent('pickstart')
    },
    pickend() {
      this.triggerEvent('pickend')
    },
    getSelectedInfo() {
      const { selectedText, selectedVal, selectedIndex } = this.$refs.picker.getSelectedInfo()
      const [t1, t2, t3 = ''] = selectedText
      const [v1, v2, v3 = 0] = selectedVal
      const info = {
        selectedIndex,
        selectedText: `${t1}${t2}${t3}`,
        selectedTime: v3 ? v1 + (v2 * 60 * 60 * 1000) + (v3 * 60 * 1000) : this.now
      }
      return info
    },
    change(event) {
      if (this.fromSetTime) {
        this.fromSetTime = false
      } else {
        const [t1, t2, t3 = ''] = event.detail.selectedText
        const [v1, v2, v3 = 0] = event.detail.selectedVal
        const info = {
          selectedIndex: event.detail.selectedIndex,
          selectedText: `${t1}${t2}${t3}`,
          selectedTime: v3 ? v1 + (v2 * 60 * 60 * 1000) + (v3 * 60 * 1000) : this.now
        }
        this.value = info
        this.triggerEvent('change', info)
      }
    },
    columnChange(event) {
      this.triggerEvent('columnChange', event.detail)
    },
    setTime(time) {
      let index = [0, 0, 0]
      // if (time > this.min) {
      this.dataList.forEach((day, d) => {
        day.children.forEach((hour, h) => {
          hour.children.forEach((minute, m) => {
            if (time === minute.timestamp) index = [d, h, m]
          })
        })
      })
      // }
      if (this.value.selectedIndex.toString() !== index.toString()) {
        this.fromSetTime = true
        this.$refs.picker.updateIndex(index)
      }
    }
  },
  watch: {
    selectedTime: {
      handler (newVal) {
        if (newVal && newVal !== this.value.selectedTime) {
          this.$nextTick(() => {
            this.setTime(newVal)
          })
        }
      },
      immediate: true
    }
  }
})
</script>

<style lang="stylus">

</style>

<script type="application/json">
{
  "component": true,
  "usingComponents": {
    "cascade-picker": "@didi/mpx-cube-ui/lib/components/cascade-picker/index.mpx"
  }
}
</script>
